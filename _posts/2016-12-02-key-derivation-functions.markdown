---
layout: post
title:  "Key derivation functions"
date:   2016-12-02 11:23:41 +0200
categories: crypto
---

During this period I've started collaborating with the crypto lab in my university (maybe there is a future as a researcher for me?) so from now on a good number of my future posts will be about cryptography.<!--more-->

Some of my friends asked me on what I'm currently working so I've decided to make a little blog post about it (this way next time someone asks me I just have to link this post). I also find quite important to be able to present a problem you're currently trying to solve in a simple and accessible way because you must keep the difficulties of the problem without all the difficult words.

So, I'm currently working on Key Derivation Functions (KDF for short). The main idea about them is simple: a lot of cryptographic algorithms like AES128 require a key with a specific length. For example, AES128 requires a 128 bit key which means a password long 16 characters! This is a problem for usability, since it's difficult to use a password this long in several occasions (think about unlocking a smartphone). Also, there is the problem that the user's password can be longer than 16 characters. Obviously we can't use some simple extensions of the key (like adding all zeros at the end) because if in a key 64 bits are padding, the only part an attacker has to guess is the first 64 bits: this means less possible passwords. A KDF is a function that convert a password to a fixed-sized key in a "secure" way.

How can be more "secure" than other methods? Even with a KDF, our main problem is that the password is often much shorter than a key so it's possible to try them all (this is called a "brute force attack"). Even with a KDF we can try all the passwords since what the user (and the attacker) has to input is the password and not the real key. For solving this problem, KDFs are created in a way that makes them hard to calculate: for converting a single password the computer has to do a lot work. The point is that if, for example, our KDF takes 82 ms for converting a password to a key (not a random number), we need almost three years to try all the passwords with 6 alphanumeric characters!

There are several KDFs but the most common is PBKDF2. PBKDF2 is not very difficult but it's quite long so I'll use a simplified version ([here](https://en.wikipedia.org/wiki/PBKDF2) you can see the complete version of the algorithm):

{% highlight c %}
PBKDF2 (P, S, i) = U(1) + ... + U(i)
U(1) = H(P, S)
U(i) = H(P, U(i-1))
{% endhighlight %}

We can safely ignore what H does because from this simple version we can already see the main concept behind PBKDF2, what's make it "hard to calculate": the final password is generated by adding "i" numbers together and each of these numbers is generated using its predecessor: this way we must generate all the "i" numbers and we can't "skip" one of them. The "i" basically represents the "hard" part I was talking about before: if "i" is a big number (like 10000), we need to calculate a lot of numbers and this will take some time.

For example, on a Wi-Fi router, the "i" parameter is set to 4096: for converting the password into the encryption key we need to calculate 4096 numbers. If we assume that this will take around 10 ms, for a user with the correct password generating the key will requires an almost imperceptible amount of time. However, let's think if we don't have the password: this means we can try only around 100 password per second. These seems a lot but if we have a password with 6 characters we need almost 252 days to try all the possible passwords at this speed!

What if we can speed up the generation of U(i)? This way we can do the same number of U(i) in less time and maybe this will make our brute force attack doable (for example, if we can reduce the time to 7 ms, our 252 days will become 176 which is a nice improvement). Also, there is the possibility to execute more instances of PBKDF2 on different processors: if we have two processors, we can execute two PBKDF2 (and try two passwords) at the same time.

Is it possible to speed up the algorithm and how we can do it? Is it possible to execute it concurrently while keeping the cost of the entire attack (both in time and money, since more processors means more money necessary for the attack) as cheap as possible? Those are the questions I'm trying to answer at the moment.